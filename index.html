    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>ESP32 Tremor Control</title>
        <!-- Tailwind CSS for modern styling -->
        <script src="https://cdn.tailwindcss.com"></script>
        <!-- Chart.js for data visualization -->
        <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
        <!-- Font Awesome for play and trash icons -->
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
        
        <!-- PWA Manifest Link - THIS IS NEW/UNCOMMENTED -->
        <link rel="manifest" href="/manifest.json"> 

        <style>
            /* Custom styles for better appearance and responsiveness */
            body {
                font-family: 'Inter', sans-serif;
                background-color: #f0f4f8; /* Light gray background */
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                min-height: 100vh;
                margin: 0;
                padding: 10px; /* Reverted to more comfortable padding */
                box-sizing: border-box;
                color: #333;
            }
            .container {
                background-color: #ffffff;
                padding: 20px; /* Reverted to more comfortable padding */
                border-radius: 15px;
                box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1);
                width: 100%;
                max-width: 350px; /* Reverted to a more readable overall app width */
                box-sizing: border-box;
            }
            h2 {
                color: #2c3e50;
                text-align: center;
                margin-bottom: 20px;
                font-size: 1.6rem;
                font-weight: bold;
            }
            .mode-section h3 {
                font-size: 0.95rem;
                margin-bottom: 10px;
            }
            label {
                display: flex;
                align-items: center;
                margin-bottom: 10px;
                font-size: 0.9rem;
                cursor: pointer;
            }
            input[type="radio"] {
                margin-right: 8px;
                transform: scale(1.1);
            }
            input[type="range"] {
                width: calc(100% - 100px); /* Adjusted width to fit label and value */
                margin-left: 10px;
                -webkit-appearance: none;
                appearance: none;
                height: 6px;
                background: #ddd;
                outline: none;
                border-radius: 5px;
                transition: opacity .2s;
            }
            input[type="range"]::-webkit-slider-thumb {
                -webkit-appearance: none;
                appearance: none;
                width: 18px;
                height: 18px;
                border-radius: 50%;
                background: #3b82f6;
                cursor: pointer;
                box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            }
            input[type="range"]::-moz-range-thumb {
                width: 18px;
                height: 18px;
                border-radius: 50%;
                background: #3b82f6;
                cursor: pointer;
                box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            }
            #controlLabel {
                font-weight: bold;
                min-width: 90px;
                display: inline-block;
                font-size: 0.9rem;
            }
            #controlVal {
                display: inline-block;
                min-width: 35px;
                text-align: right;
                font-weight: bold;
                color: #3b82f6;
                font-size: 0.9rem;
            }
            /* Wrapper for the chart to control its size independently */
            .chart-wrapper {
                background-color: #fcfcfc;
                border-radius: 10px;
                margin-top: 20px;
                padding: 10px;
                box-shadow: inset 0 0 8px rgba(0,0,0,0.05);
                width: 100%; /* Fill parent container */
                height: 200px; /* Adjusted height for the graph wrapper */
                box-sizing: border-box;
                position: relative;
                margin-left: auto;
                margin-right: auto;
            }
            canvas {
                width: 100% !important; /* Force canvas to fill its wrapper */
                height: 100% !important; /* Force canvas to fill its wrapper */
            }
            .mode-section, .slider-section {
                display: flex;
                flex-direction: column;
                margin-bottom: 15px;
                padding: 12px;
                background-color: #e2e8f0;
                border-radius: 10px;
            }
            /* Empty space after the graph */
            .spacer {
                height: 50px; /* Adjust this value for more or less empty space */
                width: 100%;
            }

            /* Styles for the tremor severity indicator */
            /* Removed width, max-width, margin-top from here as they are now managed by flex container */
            .tremor-indicator-section {
                background-color: #e2e8f0;
                padding: 12px;
                border-radius: 10px;
                box-sizing: border-box;
                text-align: center;
                display: flex;
                flex-direction: column;
                align-items: center;
            }
            #severityText {
                font-size: 1.1rem;
                font-weight: bold;
                margin-bottom: 5px;
            }
            #timestampText {
                font-size: 0.85rem;
                color: #666;
                margin-bottom: 5px; /* Added margin for space below timestamp */
            }
            #sourceNote {
                font-size: 0.75rem;
                color: #888;
                text-align: center;
                max-width: 90%; /* Keep it within the indicator section */
            }
            /* Severity specific colors */
            .severity-low { color: #22c55e; /* Tailwind green-500 */ }
            .severity-moderate { color: #facc15; /* Tailwind yellow-400 */ }
            .severity-high { color: #ef4444; /* Tailwind red-500 */ }
            .severity-na { color: #6b7280; /* Tailwind gray-500 */ }

            /* AI Personalisation Button */
            #aiPersonalisationBtn {
                background-color: #10b981; /* Tailwind emerald-500 */
                color: white;
                padding: 10px 15px;
                border-radius: 10px;
                font-weight: bold;
                cursor: pointer;
                margin-top: 15px;
                width: 100%;
                box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                transition: background-color 0.2s ease-in-out;
            }
            #aiPersonalisationBtn:hover {
                background-color: #059669; /* Darker emerald on hover */
            }

            /* Personalisation View styles */
            #personalisationView {
                display: none; /* Hidden by default */
                flex-direction: column;
                align-items: center;
                width: 100%;
                max-width: 350px;
                padding: 20px;
                background-color: #ffffff;
                border-radius: 15px;
                box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1);
                box-sizing: border-box;
            }
            #personalisationView h3 {
                font-size: 1.2rem;
                margin-bottom: 15px;
                color: #2c3e50;
            }
            .day-button-container {
                display: flex;
                flex-wrap: wrap;
                justify-content: center;
                gap: 10px;
                margin-bottom: 20px;
                width: 100%;
            }
            .day-button {
                background-color: #60a5fa; /* Tailwind blue-400 */
                color: white;
                padding: 10px 15px;
                border-radius: 8px;
                font-weight: bold;
                cursor: pointer;
                flex: 1 1 calc(33% - 10px); /* 3 buttons per row, with gap */
                box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
                min-width: 90px; /* Ensure minimum width for day buttons */
                text-align: center;
                position: relative; /* For recording indicator */
            }
            .day-button:hover {
                background-color: #3b82f6; /* Darker blue on hover */
                transform: translateY(-2px);
            }
            .day-button.recording {
                background-color: #dc2626; /* Red for recording */
                animation: pulse-red 1s infinite alternate;
            }
            .day-button.recording::after {
                content: "REC";
                position: absolute;
                top: 5px;
                right: 5px;
                font-size: 0.7em;
                font-weight: bold;
                color: white;
                background-color: rgba(0,0,0,0.5);
                padding: 2px 4px;
                border-radius: 3px;
            }
            @keyframes pulse-red {
                from { box-shadow: 0 0 0 0 rgba(220, 38, 38, 0.7); }
                to { box-shadow: 0 0 0 8px rgba(220, 38, 38, 0); }
            }

            .day-details {
                background-color: #f8fafc;
                padding: 10px;
                border-radius: 8px;
                margin-top: 10px;
                font-size: 0.85rem;
                text-align: left;
                width: 100%;
                box-shadow: inset 0 1px 3px rgba(0,0,0,0.05);
            }
            .day-details p {
                margin-bottom: 5px;
            }
            /* New styles for consolidated session display */
            .day-session-group {
                border: 1px solid #cbd5e1;
                border-radius: 8px;
                padding: 8px;
                margin-bottom: 10px;
                background-color: #eef2f6;
            }
            .day-session-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                font-weight: bold;
                margin-bottom: 5px;
                color: #2c3e50;
            }
            .consolidated-steps-list p {
                margin: 2px 0;
                padding-left: 10px;
                border-left: 2px solid #94a3b8;
            }
            .toggle-session-icon {
                cursor: pointer;
                margin-left: 8px; /* Space between text and icon */
                transition: transform 0.2s ease-in-out;
            }
            .toggle-session-icon.rotated {
                transform: rotate(180deg);
            }

            .play-button, .delete-button {
                background-color: #22c55e; /* Tailwind green-500 for play */
                color: white;
                padding: 5px 8px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 0.8em;
                transition: background-color 0.2s ease-in-out;
                margin-left: 5px; /* Space between play and delete */
            }
            .play-button:hover {
                background-color: #16a34a; /* Darker green on hover */
            }
            .delete-button {
                background-color: #ef4444; /* Tailwind red-500 for delete */
                color: white; /* Ensure text is white */
            }
            .delete-button:hover {
                background-color: #dc2626; /* Darker red on hover */
            }
            .home-button {
                background-color: #64748b; /* Tailwind slate-500 */
                color: white;
                padding: 10px 20px;
                border-radius: 10px;
                font-weight: bold;
                cursor: pointer;
                margin-top: 20px;
                width: 100%;
                box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                transition: background-color 0.2s ease-in-out;
            }
            .home-button:hover {
                background-color: #475569; /* Darker slate on hover */
            }

            /* Modal Styles */
            .modal-overlay {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0, 0, 0, 0.6);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 1000;
                backdrop-filter: blur(3px); /* Optional: blur background */
            }
            .modal-content {
                background-color: #ffffff;
                padding: 25px;
                border-radius: 15px;
                box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
                width: 90%;
                max-width: 400px;
                position: relative;
                animation: fadeIn 0.3s ease-out;
                display: flex; /* Use flex for modal content layout */
                flex-direction: column; /* Stack header, body */
                max-height: 90vh; /* Limit overall modal height */
            }
            .modal-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 15px;
                border-bottom: 1px solid #eee;
                padding-bottom: 10px;
                flex-shrink: 0; /* Prevent header from shrinking */
            }
            .modal-header h4 {
                font-size: 1.3rem;
                color: #2c3e50;
                font-weight: bold;
            }
            .modal-close-button {
                background: none;
                border: none;
                font-size: 1.8rem;
                color: #666;
                cursor: pointer;
                padding: 0;
                line-height: 1;
                transition: color 0.2s ease-in-out;
            }
            .modal-close-button:hover {
                color: #333;
            }
            .modal-body {
                flex-grow: 1; /* Allow body to take available space */
                overflow-y: auto; /* Enable vertical scrolling */
                padding-right: 10px; /* Add padding for scrollbar */
            }
            .modal-body p {
                margin-bottom: 10px;
                font-size: 0.9rem;
                line-height: 1.5;
                color: #555;
            }
            .modal-body ul {
                list-style-type: disc;
                margin-left: 20px;
                font-size: 0.85rem;
                color: #555;
            }
            .modal-body ul li {
                margin-bottom: 5px;
            }

            /* Bluetooth Connection Screen Styles */
            #bluetoothConnectScreen {
                display: flex; /* Initially shown */
                flex-direction: column;
                align-items: center;
                justify-content: center;
                background-color: #ffffff;
                padding: 20px;
                border-radius: 15px;
                box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1);
                width: 100%;
                max-width: 350px;
                box-sizing: border-box;
            }
            #bluetoothConnectScreen .btn {
                background-color: #3b82f6; /* Blue button */
                color: white;
                padding: 10px 15px;
                border-radius: 10px;
                font-weight: bold;
                cursor: pointer;
                width: 100%;
                box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                transition: background-color 0.2s ease-in-out;
            }
            #bluetoothConnectScreen .btn:hover {
                background-color: #2563eb; /* Darker blue on hover */
            }
            .status-message {
                margin-top: 15px;
                font-size: 0.9rem;
                text-align: center;
                padding: 8px;
                border-radius: 8px;
                width: 100%;
            }
            .status-success {
                background-color: #d1fae5; /* Green light */
                color: #065f46; /* Green dark */
            }
            .status-error {
                background-color: #fee2e2; /* Red light */
                color: #991b1b; /* Red dark */
            }
            .status-info {
                background-color: #e0f2fe; /* Blue light */
                color: #1e40af; /* Blue dark */
            }
            .disclaimer {
                font-size: 0.75rem;
                color: #777;
                margin-top: 15px;
                text-align: center;
                line-height: 1.4;
            }


            @keyframes fadeIn {
                from { opacity: 0; transform: translateY(-20px); }
                to { opacity: 1; transform: translateY(0); }
            }

            /* Responsive adjustments */
            @media (max-width: 640px) {
                body {
                    padding: 10px;
                }
                .container {
                    padding: 15px;
                    max-width: 95%;
                }
                h2 {
                    font-size: 1.4rem;
                }
                label {
                    font-size: 0.85rem;
                }
                input[type="range"] {
                    width: calc(100% - 90px);
                }
                #controlLabel {
                    min-width: 80px;
                }
                .chart-wrapper {
                    height: 160px; /* Adjusted height for very small screens */
                }
                .spacer {
                    height: 30px; /* Adjust spacer height for mobile */
                }
                /* Adjustments for the new flex container in responsive mode */
                .flex-container-indicator-image {
                    flex-direction: column; /* Stack vertically on small screens */
                    gap: 10px; /* Adjust gap for stacked items */
                }
                .tremor-indicator-section, .image-link-wrapper {
                    width: 100%; /* Full width when stacked */
                }
                #severityText {
                    font-size: 1rem;
                }
                #timestampText {
                    font-size: 0.8rem;
                }
                #sourceNote {
                    font-size: 0.7rem;
                }
                .day-button {
                    flex: 1 1 calc(50% - 10px); /* 2 buttons per row on small screens */
                }
                .modal-content {
                    padding: 15px;
                }
                .modal-header h4 {
                    font-size: 1.1rem;
                }
                .modal-close-button {
                    font-size: 1.5rem;
                }
                .modal-body p, .modal-body ul li {
                    font-size: 0.8rem;
                }
            }
        </style>
    </head>
    <body>
        <!-- Bluetooth Connection Screen (Initial View) -->
        <div id="bluetoothConnectScreen" class="container">
            <h2 class="text-center mb-6">Connect to ESP32 via Bluetooth</h2>
            <button id="connectBluetoothBtn" class="btn">Connect to ESP32</button>
            <div id="bluetoothConnectionStatus" class="status-message mt-3 hidden"></div>
            <p class="disclaimer">
                *This feature requires a browser that supports Web Bluetooth (e.g., Chrome, Edge, Opera, Samsung Internet).
                It will NOT work on Safari (iOS) or Firefox. The app must also be served over HTTPS.
            </p>
        </div>

        <div id="mainApp" class="container" style="display: none;">
            <h2>ESP32 Tremor Monitor (UI Demo)</h2>

            <div class="mode-section">
                <h3>Select Mode:</h3>
                <label>
                    <input type='radio' id='manualModeRadio' name='controlMode'>
                    Manual Mode (Continuous Vibrate)
                </label>
                <label>
                    <input type='radio' id='simpleAnalysisModeRadio' name='controlMode'>
                    Simple Tremor Analysis Mode (m/s<sup>2</sup>)
                </label>
                <label>
                    <input type='radio' id='fftAnalysisModeRadio' name='controlMode' checked>
                    FFT Tremor Analysis Mode (Sum of Magnitudes in a Frequency Band)
                </label>
            </div>

            <div class="slider-section">
                <!-- Dynamic Control Slider -->
                <span id='controlLabel'>Control Slider: </span>
                <input type='range' id='controlSlider' min='0' max='1023'>
                <span id='controlVal'></span>
            </div>

            <div class="chart-wrapper">
                <canvas id='chart'></canvas>
            </div>

            <!-- Container for Indicator and Image -->
            <div class="flex flex-col md:flex-row items-stretch justify-between w-full mt-4 mb-4 gap-4 h-36 flex-container-indicator-image">
                <!-- Tremor Severity Indicator -->
                <div class="tremor-indicator-section w-full md:w-1/2 h-full">
                    <span id="severityText">Severity: N/A</span>
                    <span id="timestampText">Last Updated: --:----</span>
                    <div id="sourceNote">
                        *Severity classification based on general clinical understanding, not a specific diagnostic scale.
                    </div>
                </div>

                <!-- Image Link -->
                <a href="https://www.google.com" target="_blank" class="block w-full md:w-1/2 h-full flex-shrink-0 image-link-wrapper">
                    <img src="https://placehold.co/350x128/ADD8E6/000000?text=350x128" alt="Placeholder Image Link" class="w-full h-full object-cover rounded-lg shadow-md cursor-pointer">
                </a>
            </div>

            <!-- AI Personalisation Button -->
            <button id="aiPersonalisationBtn">AI Personalisation</button>

            <!-- Empty space after the graph (kept for consistent spacing if needed elsewhere, though now minimal) -->
            <div class="spacer"></div>
        </div>

        <!-- Personalisation View (hidden by default) -->
        <div id="personalisationView" class="container" style="display: none;">
            <div class="flex justify-between items-center mb-4">
                <h3>AI Personalisation - Record & Playback</h3>
                <button id="helpButton" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-1 px-3 rounded-full text-sm">
                    Help
                </button>
            </div>
            <div class="day-button-container" id="dayButtonsContainer">
                <!-- Day buttons will be dynamically added here -->
            </div>
            <button id="homeBtn" class="home-button">Home</button>
        </div>

        <!-- Help Modal (hidden by default) -->
        <div id="helpModal" class="modal-overlay hidden">
            <div class="modal-content">
                <div class="modal-header">
                    <h4>How AI Personalisation Works</h4>
                    <button class="modal-close-button" id="closeModalButton">&times;</button>
                </div>
                <div class="modal-body">
                    <p>This section allows you to record and playback personalized tremor control sessions for each day of the week.</p>
                    <ul>
                        <li><strong>Day Buttons (e.g., Monday, Tuesday):</strong>
                            <ul>
                                <li>Click a day button to <strong>start recording</strong> a new session for that day. The button will show "REC".</li>
                                <li>Click the <strong>same day button again to stop recording</strong>. The session will be saved.</li>
                                <li>Starting a new recording on a different day will automatically stop any active recording.</li>
                            </ul>
                        </li>
                        <li><strong>Recorded Sessions:</strong>
                            <ul>
                                <li>Each recorded session shows its start and end time.</li>
                                <li><i class="fas fa-chevron-down"></i> <strong>Dropdown Icon:</strong> Click this icon to expand or collapse the detailed list of recorded steps (mode and slider values) within that session.</li>
                                <li><i class="fas fa-play"></i> <strong>Play Button:</strong> Click to play back the recorded session on the main control screen. If a session is playing, click again to pause it. Click a third time to resume. Playing a new session or starting a recording will stop current playback.</li>
                                <li><i class="fas fa-trash"></i> <strong>Delete Button:</strong> Click to permanently delete a recorded session.</li>
                            </ul>
                        </li>
                    </ul>
                    <p class="mt-4">Your recorded sessions are saved locally on your device.</p>
                </div>
            </div>
        </div>

        <script>
            const ctx = document.getElementById('chart').getContext('2d');
            const data = {
                labels: [],
                datasets: [{
                    label: 'Simulated Tremor Metric', // This label will change based on mode
                    data: [],
                    borderColor: '#ef4444', /* Tailwind red-500 */
                    backgroundColor: 'rgba(239, 68, 68, 0.2)', /* Light red fill */
                    fill: true,
                    tension: 0.3, /* Smooth lines */
                    pointRadius: 2,
                    pointBackgroundColor: '#ef4444'
                }]
            };
            const chart = new Chart(ctx, {
                type: 'line',
                data: data,
                options: {
                    animation: false, // Disable animation for real-time updates
                    responsive: true,
                    maintainAspectRatio: false, // Allow canvas to resize freely
                    scales: {
                        y: {
                            beginAtZero: true,
                            suggestedMin: 0,
                            suggestedMax: 500, // Adjust based on your expected FFT/Live magnitudes
                            title: {
                                display: true,
                                text: 'Value',
                                font: { size: 8 } // Smaller font for axis title
                            },
                            ticks: {
                                font: { size: 7 } // Smaller font for axis ticks
                            }
                        }
                        ,
                        x: {
                            title: {
                                display: true,
                                text: 'Time',
                                font: { size: 8 } // Smaller font for axis title
                            },
                            ticks: {
                                font: { size: 7 } // Smaller font for axis ticks
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                            labels: {
                                font: { size: 8 } // Smaller font for legend
                            }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            titleFont: { size: 8 }, // Smaller font for tooltip title
                            bodyFont: { size: 8 } // Smaller font for tooltip body
                        }
                    }
                }
            });

            // --- AI Personalisation Feature Logic ---
            const mainApp = document.getElementById('mainApp');
            const personalisationView = document.getElementById('personalisationView');
            const aiPersonalisationBtn = document.getElementById('aiPersonalisationBtn');
            const homeBtn = document.getElementById('homeBtn');
            const dayButtonsContainer = document.getElementById('dayButtonsContainer');
            const helpButton = document.getElementById('helpButton');
            const helpModal = document.getElementById('helpModal');
            const closeModalButton = document.getElementById('closeModalButton');

            const daysOfWeek = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
            // Structure to store recorded data: { 'Monday': { isRecording: false, sessions: [{ startTime: 'HH:MM', endTime: 'HH:MM', steps: [{time: 'HH:MM:SS', mode: '...', sliderVal: ...}, ... ] }] }, ... }
            let recordedData = {};
            try {
                recordedData = JSON.parse(localStorage.getItem('tremorRecordedData')) || {};
            } catch (e) {
                console.error("Error parsing recorded data from localStorage:", e);
                // If parsing fails, start with an empty object to prevent further errors
                recordedData = {};
            }


            // Robust initialization: Ensure each day has a proper structure upon load
            daysOfWeek.forEach(day => {
                if (!recordedData[day] || typeof recordedData[day] !== 'object' || !Array.isArray(recordedData[day].sessions)) {
                    console.warn(`Correcting corrupted or missing data for day: ${day}. Initializing with empty sessions.`);
                    recordedData[day] = { isRecording: false, sessions: [] };
                }
            });
            console.log('Initial recordedData after setup:', recordedData); // For debugging purposes

            let recordingInterval = null;
            let currentRecordingDay = null;
            let currentRecordingSession = null; // Stores the object for the current session being recorded

            // Playback variables
            let playbackInterval = null;
            let currentPlayingSessionId = null; // Tracks the ID of the session currently being played
            let currentPlaybackStepIndex = 0; // Tracks the current step in the playback

            // Set to store IDs of currently expanded session detail lists
            let expandedSessions = new Set();

            function saveRecordedData() {
                localStorage.setItem('tremorRecordedData', JSON.stringify(recordedData));
            }

            /**
             * Consolidates raw per-second recording steps into time-ranged segments.
             * @param {Array} steps - Array of {time, mode, sliderVal} objects.
             * @returns {Array} Consolidated segments with {startTime, endTime, mode, sliderVal}.
             */
            function consolidateSessionSteps(steps) {
                if (!steps || steps.length === 0) {
                    return [];
                }

                const consolidated = [];
                let currentSegment = {
                    startTime: steps[0].time,
                    endTime: steps[0].time, // Will be updated
                    mode: steps[0].mode,
                    sliderVal: steps[0].sliderVal
                };

                for (let i = 1; i < steps.length; i++) {
                    const step = steps[i];
                    // If mode and slider value are the same, extend the current segment
                    if (step.mode === currentSegment.mode && step.sliderVal === currentSegment.sliderVal) {
                        currentSegment.endTime = step.time; // Extend the end time
                    } else {
                        // Different setting, close current segment and start a new one
                        consolidated.push(currentSegment);
                        currentSegment = {
                            startTime: step.time,
                            endTime: step.time, // Will be updated
                            mode: step.mode,
                            sliderVal: step.sliderVal
                        };
                    }
                }
                // Add the last segment
                consolidated.push(currentSegment);

                return consolidated;
            }


            function renderDayButtons() {
                dayButtonsContainer.innerHTML = ''; // Clear previous buttons
                daysOfWeek.forEach(day => {
                    // Ensure the day entry exists in recordedData (redundant with robust init, but safe)
                    if (!recordedData[day]) {
                        recordedData[day] = { isRecording: false, sessions: [] };
                        saveRecordedData();
                    }

                    const dayDiv = document.createElement('div');
                    dayDiv.className = 'day-item'; // A wrapper for button and details

                    const dayButton = document.createElement('button');
                    dayButton.className = `day-button ${recordedData[day].isRecording ? 'recording' : ''}`;
                    dayButton.textContent = day;
                    dayButton.dataset.day = day; // Store day name for easy access

                    const dayDetails = document.createElement('div');
                    dayDetails.className = 'day-details';
                    dayDetails.id = `details-${day}`;

                    const hasSessions = recordedData[day].sessions.length > 0;
                    if (hasSessions) {
                        dayDetails.innerHTML = '<p class="font-bold mb-2">Recorded Sessions:</p>';
                        recordedData[day].sessions.forEach((session, sessionIndex) => {
                            // Create a group for each full recording session
                            const sessionGroupDiv = document.createElement('div');
                            sessionGroupDiv.className = 'day-session-group';

                            const sessionHeaderDiv = document.createElement('div');
                            sessionHeaderDiv.className = 'day-session-header';
                            sessionHeaderDiv.innerHTML = `
                                <span>Session: ${session.startTime} - ${session.endTime === 'Recording...' ? 'Recording...' : session.endTime}</span>
                                <i class="fas fa-chevron-down toggle-session-icon"></i>
                                <div>
                                    <button class="play-button" data-day="${day}" data-session-index="${sessionIndex}">
                                        <i class="fas fa-play"></i>
                                    </button>
                                    <button class="delete-button" data-day="${day}" data-session-index="${sessionIndex}">
                                        <i class="fas fa-trash"></i>
                                    </button>
                                </div>
                            `;
                            sessionGroupDiv.appendChild(sessionHeaderDiv);

                            const consolidatedStepsListDiv = document.createElement('div');
                            const sessionId = `${day}-${sessionIndex}`; // Use this for expandedSessions
                            consolidatedStepsListDiv.id = `session-details-${sessionId}`; // Actual DOM ID
                            
                            // Check if this session was previously expanded and apply 'hidden' class accordingly
                            if (!expandedSessions.has(sessionId)) {
                                consolidatedStepsListDiv.classList.add('hidden');
                            }
                            consolidatedStepsListDiv.classList.add('consolidated-steps-list'); // Add base class

                            // Also update the icon based on initial state
                            const toggleIcon = sessionHeaderDiv.querySelector('.toggle-session-icon');
                            if (toggleIcon) {
                                if (expandedSessions.has(sessionId)) {
                                    toggleIcon.classList.remove('fa-chevron-down');
                                    toggleIcon.classList.add('fa-chevron-up');
                                } else {
                                    toggleIcon.classList.remove('fa-chevron-up');
                                    toggleIcon.classList.add('fa-chevron-down');
                                }
                            }

                            // Update play button icon if this session is currently playing AND playback is active
                            const playButtonIcon = sessionHeaderDiv.querySelector('.play-button i');
                            if (playButtonIcon) {
                                if (currentPlayingSessionId === sessionId && playbackInterval !== null) {
                                    playButtonIcon.classList.remove('fa-play');
                                    playButtonIcon.classList.add('fa-pause');
                                } else {
                                    playButtonIcon.classList.remove('fa-pause');
                                    playButtonIcon.classList.add('fa-play');
                                }
                            }


                            if (session.steps && session.steps.length > 0) {
                                const consolidatedDisplay = consolidateSessionSteps(session.steps);
                                consolidatedDisplay.forEach(segment => {
                                    const p = document.createElement('p');
                                    p.textContent = `${segment.startTime} - ${segment.endTime}: ${segment.mode}, Slider: ${segment.sliderVal}`;
                                    consolidatedStepsListDiv.appendChild(p);
                                });
                            } else if (session.endTime !== 'Recording...') {
                                // Only show "No steps" if recording has actually finished and there are no steps
                                const p = document.createElement('p');
                                p.textContent = 'No steps recorded for this session.';
                                consolidatedStepsListDiv.appendChild(p);
                            }
                            sessionGroupDiv.appendChild(consolidatedStepsListDiv);
                            dayDetails.appendChild(sessionGroupDiv);
                        });
                    } else {
                        dayDetails.innerHTML = '<p>No sessions recorded.</p>';
                    }


                    dayDiv.appendChild(dayButton);
                    dayDiv.appendChild(dayDetails);
                    dayButtonsContainer.appendChild(dayDiv);
                });

                // Attach event listeners to newly created buttons
                document.querySelectorAll('.day-button').forEach(button => {
                    button.onclick = toggleRecording;
                });
                document.querySelectorAll('.play-button').forEach(button => {
                    button.onclick = playRecordedSession;
                });
                document.querySelectorAll('.delete-button').forEach(button => {
                    button.onclick = deleteRecordedSession;
                });
                // Attach event listeners for the new toggle icons
                document.querySelectorAll('.toggle-session-icon').forEach(icon => {
                    icon.addEventListener('click', (e) => {
                        const sessionGroup = e.target.closest('.day-session-group');
                        const detailsList = sessionGroup.querySelector('.consolidated-steps-list');
                        // Get the session ID from the play button's dataset
                        const playButton = sessionGroup.querySelector('.play-button');
                        const sessionId = `${playButton.dataset.day}-${playButton.dataset.sessionIndex}`;

                        detailsList.classList.toggle('hidden');
                        e.target.classList.toggle('fa-chevron-down');
                        e.target.classList.toggle('fa-chevron-up');

                        // Update the expandedSessions set
                        if (detailsList.classList.contains('hidden')) {
                            expandedSessions.delete(sessionId);
                        } else {
                            expandedSessions.add(sessionId);
                        }
                    });
                });
            }

            function toggleRecording(event) {
                console.log("toggleRecording called. Event Target:", event.target);
                const clickedButton = event.target.closest('.day-button');
                if (!clickedButton) {
                    console.error("toggleRecording: Clicked element or its parent is not a .day-button.");
                    return;
                }

                const day = clickedButton.dataset.day;
                console.log("toggleRecording: Extracted day:", day);

                // Stop any ongoing playback first
                stopPlayback(); // Stop playback when starting/stopping a recording

                // Scenario 1: User clicks the day that is currently recording -> STOP recording
                if (currentRecordingDay === day) {
                    clearInterval(recordingInterval);
                    recordingInterval = null;
                    recordedData[day].isRecording = false;
                    if (currentRecordingSession && currentRecordingSession.endTime === 'Recording...') {
                        currentRecordingSession.endTime = new Date().toLocaleTimeString(); // Finalize end time
                        console.log(`Stopped recording for ${day}. Finalized session:`, currentRecordingSession);
                    }
                    currentRecordingDay = null;
                    currentRecordingSession = null;
                    saveRecordedData(); // Save changes
                    renderDayButtons(); // Re-render to show updated end time and remove REC indicator
                }
                // Scenario 2: User clicks a different day, or no day is currently recording -> START recording
                else {
                    // If another day was recording, stop it first (clean up previous recording)
                    if (currentRecordingDay) {
                        clearInterval(recordingInterval);
                        recordedData[currentRecordingDay].isRecording = false;
                        if (currentRecordingSession && currentRecordingSession.endTime === 'Recording...') {
                            currentRecordingSession.endTime = new Date().toLocaleTimeString();
                            console.log(`Stopped recording for ${currentRecordingDay}. Finalized session:`, currentRecordingSession);
                        }
                        saveRecordedData(); // Save changes for the previously recording day
                        // No renderDayButtons() here for the *previous* day, as the next render will cover it.
                    }

                    // Start recording for the new day
                    recordedData[day].isRecording = true;
                    currentRecordingDay = day;
                    const startTime = new Date().toLocaleTimeString();
                    currentRecordingSession = {
                        startTime: startTime,
                        endTime: 'Recording...', // Placeholder until stopped
                        steps: [] // Store individual steps here
                    };
                    recordedData[day].sessions.push(currentRecordingSession);
                    console.log(`Started recording for ${day}. New session:`, currentRecordingSession);
                    saveRecordedData(); // Save new session immediately
                    renderDayButtons(); // Re-render to show REC indicator and new session entry

                    // Update recording data every second
                    recordingInterval = setInterval(() => {
                        if (currentRecordingSession) {
                            currentRecordingSession.steps.push({
                                time: new Date().toLocaleTimeString(),
                                mode: getCurrentModeLabel(),
                                sliderVal: parseFloat(controlSlider.value)
                            });
                            saveRecordedData(); // Save frequently
                            // IMPORTANT: Removed renderDayButtons() call from here to prevent immediate collapse
                        }
                    }, 1000); // Record every second
                }
            }

            function stopPlayback() {
                console.log("stopPlayback called.");
                if (playbackInterval) {
                    clearInterval(playbackInterval);
                    playbackInterval = null;
                    console.log("Playback interval cleared.");
                }
                if (currentPlayingSessionId) {
                    console.log(`Stopping session: ${currentPlayingSessionId}`);
                    const [day, index] = currentPlayingSessionId.split('-');
                    const playButton = document.querySelector(`.play-button[data-day="${day}"][data-session-index="${index}"] i`);
                    if (playButton) {
                        playButton.classList.remove('fa-pause');
                        playButton.classList.add('fa-play');
                        console.log("Play button icon reset.");
                    }
                    currentPlayingSessionId = null;
                    currentPlaybackStepIndex = 0; // Reset step index only on full stop
                    console.log("currentPlayingSessionId and currentPlaybackStepIndex reset.");
                }
            }

            function playRecordedSession(event) {
                console.log("playRecordedSession called. Event Target:", event.target);
                const clickedPlayButton = event.target.closest('.play-button');
                if (!clickedPlayButton) {
                    console.error("playRecordedSession: Clicked element or its parent is not a .play-button.");
                    return;
                }

                const day = clickedPlayButton.dataset.day;
                const sessionIndex = parseInt(clickedPlayButton.dataset.sessionIndex);
                const thisSessionId = `${day}-${sessionIndex}`;
                console.log("playRecordedSession: Extracted day:", day, "Index:", sessionIndex, "Session ID:", thisSessionId);

                // Defensive check
                if (!recordedData[day] || !Array.isArray(recordedData[day].sessions) || !recordedData[day].sessions[sessionIndex]) {
                    console.error(`Error: Data for day '${day}' or session index ${sessionIndex} is corrupted or missing.`);
                    // Attempt to clean up potentially bad data if it's the root cause
                    if (!recordedData[day] || !Array.isArray(recordedData[day].sessions)) {
                        recordedData[day] = { isRecording: false, sessions: [] };
                        saveRecordedData();
                        renderDayButtons();
                    }
                    return;
                }

                const sessionToPlay = recordedData[day].sessions[sessionIndex];

                // Stop any ongoing recording
                if (currentRecordingDay) {
                    clearInterval(recordingInterval);
                    recordedData[currentRecordingDay].isRecording = false;
                    if (currentRecordingSession && currentRecordingSession.endTime === 'Recording...') {
                        currentRecordingSession.endTime = new Date().toLocaleTimeString();
                    }
                    currentRecordingDay = null;
                    currentRecordingSession = null;
                    saveRecordedData();
                    renderDayButtons(); // Re-render to update the recording status
                }

                // Toggle Play/Pause for the SAME session
                if (currentPlayingSessionId === thisSessionId) {
                    if (playbackInterval) {
                        // Currently playing, so pause
                        clearInterval(playbackInterval);
                        playbackInterval = null;
                        // currentPlayingSessionId remains thisSessionId to indicate it's the paused session
                        console.log(`PAUSE: Playback paused for ${thisSessionId}. currentPlaybackStepIndex: ${currentPlaybackStepIndex}`);
                        clickedPlayButton.querySelector('i').classList.remove('fa-pause');
                        clickedPlayButton.querySelector('i').classList.add('fa-play');
                    } else {
                        // Currently paused, so resume
                        console.log(`RESUME: Playback resumed for ${thisSessionId} from step ${currentPlaybackStepIndex}. Total steps: ${sessionToPlay.steps.length}`);
                        clickedPlayButton.querySelector('i').classList.remove('fa-play');
                        clickedPlayButton.querySelector('i').classList.add('fa-pause');
                        startPlaybackInterval(sessionToPlay);
                    }
                }
                // Start playing a NEW session or if nothing was playing
                else {
                    stopPlayback(); // This calls stopPlayback() which resets currentPlaybackStepIndex to 0. This is correct for a *new* session.
                    currentPlayingSessionId = thisSessionId;
                    currentPlaybackStepIndex = 0; // Explicitly reset for new session
                    console.log(`NEW PLAY: Playback started for ${thisSessionId}. Resetting step index to 0.`);
                    clickedPlayButton.querySelector('i').classList.remove('fa-play');
                    clickedPlayButton.querySelector('i').classList.add('fa-pause');
                    switchView('main'); // Switch to main view for playback visualization
                    startPlaybackInterval(sessionToPlay);
                }
            }

            function startPlaybackInterval(sessionToPlay) {
                console.log(`startPlaybackInterval called. Initial currentPlaybackStepIndex: ${currentPlaybackStepIndex}, total steps: ${sessionToPlay.steps.length}`);
                if (!sessionToPlay || !sessionToPlay.steps || sessionToPlay.steps.length === 0) {
                    console.error("startPlaybackInterval: Session has no steps to play.");
                    stopPlayback(); // Stop if no steps
                    return;
                }
                if (currentPlaybackStepIndex >= sessionToPlay.steps.length) {
                    console.warn("startPlaybackInterval: Playback already at end of session. Stopping.");
                    stopPlayback(); // Stop if already at end
                    return;
                }

                playbackInterval = setInterval(() => {
                    if (currentPlaybackStepIndex < sessionToPlay.steps.length) {
                        const step = sessionToPlay.steps[currentPlaybackStepIndex];
                        // Apply recorded settings to the main UI
                        switch (step.mode) {
                            case 'Manual Mode (Fixed Vibrate)':
                                document.getElementById('manualModeRadio').checked = true;
                                break;
                            case 'Tremor (Simple Magnitude)':
                                document.getElementById('simpleAnalysisModeRadio').checked = true;
                                break;
                            case 'Tremor (FFT Metric)':
                                document.getElementById('fftAnalysisModeRadio').checked = true;
                                break;
                        }
                        document.getElementById('controlSlider').value = step.sliderVal;
                        updateUIState(); // Call updateUIState to refresh labels and values and indicator

                        console.log(`STEP ${currentPlaybackStepIndex + 1}/${sessionToPlay.steps.length}: Mode=${step.mode}, Slider=${step.sliderVal}`);
                        currentPlaybackStepIndex++;
                    } else {
                        // Playback finished
                        console.log("Playback finished. Calling stopPlayback.");
                        stopPlayback(); // Use the new stopPlayback function
                    }
                }, 1000); // Play each recorded step per second
            }


            function deleteRecordedSession(event) {
                console.log("deleteRecordedSession called. Event Target:", event.target);
                const clickedDeleteButton = event.target.closest('.delete-button');
                if (!clickedDeleteButton) {
                    console.error("deleteRecordedSession: Clicked element or its parent is not a .delete-button.");
                    return;
                }

                const day = clickedDeleteButton.dataset.day;
                const sessionIndex = parseInt(clickedDeleteButton.dataset.sessionIndex);
                console.log("deleteRecordedSession: Extracted day:", day, "Index:", sessionIndex);

                // Using a simple log instead of confirm() as per instructions.
                // In a real application, you'd implement a custom modal for confirmation.
                console.log(`User confirmed deletion of session for ${day} at index ${sessionIndex}.`);

                if (recordedData[day] && Array.isArray(recordedData[day].sessions)) {
                    // Stop playback if the session being deleted is currently playing
                    const sessionIdToDelete = `${day}-${sessionIndex}`;
                    if (currentPlayingSessionId === sessionIdToDelete) {
                        stopPlayback();
                    }

                    // Remove the session ID from the expandedSessions set before deleting the session data
                    expandedSessions.delete(sessionIdToDelete);

                    console.log("Sessions BEFORE deletion:", JSON.parse(JSON.stringify(recordedData[day].sessions))); // Deep copy for logging
                    console.log(`Deleting session at index ${sessionIndex}`);
                    recordedData[day].sessions.splice(sessionIndex, 1); // Remove the session
                    saveRecordedData();
                    console.log("Sessions AFTER deletion:", JSON.parse(JSON.stringify(recordedData[day].sessions))); // Deep copy for logging
                    renderDayButtons(); // Re-render to update UI
                    console.log(`Session deleted for ${day} at index ${sessionIndex}.`);
                } else {
                    console.error(`Error deleting session: Data for day '${day}' is corrupted or missing.`);
                }
            }

            function getCurrentModeLabel() {
                const manualModeChecked = document.getElementById('manualModeRadio').checked;
                const simpleAnalysisModeChecked = document.getElementById('simpleAnalysisModeRadio').checked;
                const fftAnalysisModeChecked = document.getElementById('fftAnalysisModeRadio').checked;

                if (manualModeChecked) {
                    return 'Manual Mode (Fixed Vibrate)';
                } else if (simpleAnalysisModeChecked) {
                    return 'Tremor (Simple Magnitude)';
                } else if (fftAnalysisModeChecked) {
                    return 'Tremor (FFT Metric)';
                }
                return 'Unknown Mode';
            }

            // --- View Switching Logic ---
            const VIEWS = {
                BLUETOOTH_CONNECT: 'bluetooth_connect',
                MAIN_APP: 'main_app',
                PERSONALISATION: 'personalisation',
            };
            let currentView = VIEWS.BLUETOOTH_CONNECT; // Initial view

            function showView(view) {
                document.getElementById('bluetoothConnectScreen').style.display = 'none';
                document.getElementById('mainApp').style.display = 'none';
                document.getElementById('personalisationView').style.display = 'none';

                currentView = view; // Update current view state

                switch (view) {
                    case VIEWS.BLUETOOTH_CONNECT:
                        document.getElementById('bluetoothConnectScreen').style.display = 'flex';
                        break;
                    case VIEWS.MAIN_APP:
                        document.getElementById('mainApp').style.display = 'block';
                        updateUIState(); // Ensure main app state is correct
                        break;
                    case VIEWS.PERSONALISATION:
                        document.getElementById('personalisationView').style.display = 'flex';
                        renderDayButtons(); // Render buttons when entering personalisation view
                        break;
                }
            }

            // Initial view on load
            window.onload = () => {
                updateUIState(); // Call once to set up initial chart/slider labels (even if hidden)
                showView(VIEWS.BLUETOOTH_CONNECT); // Start with the Bluetooth connection screen
            };


            aiPersonalisationBtn.addEventListener('click', () => showView(VIEWS.PERSONALISATION));
            homeBtn.addEventListener('click', () => {
                stopPlayback(); // Stop playback when navigating home
                showView(VIEWS.MAIN_APP);
            });

            // --- Help Modal Logic ---
            helpButton.addEventListener('click', () => {
                helpModal.classList.remove('hidden');
            });

            closeModalButton.addEventListener('click', () => {
                helpModal.classList.add('hidden');
            });

            // Close modal if user clicks outside of it
            helpModal.addEventListener('click', (e) => {
                if (e.target === helpModal) {
                    helpModal.classList.add('hidden');
                }
            });


            // --- Existing UI Demo Logic (Unchanged for core functionality) ---

            // Function to update the tremor severity indicator
            function updateSeverityIndicator(metricValue, modeLabel) {
                const severityTextElement = document.getElementById('severityText');
                const timestampTextElement = document.getElementById('timestampText');
                const now = new Date().toLocaleTimeString();

                let severity = "N/A";
                let severityClass = "severity-na"; // Default class

                // Determine severity based on the metric value, regardless of mode
                let scaledMetric = metricValue;

                if (modeLabel === 'Manual Mode (Fixed Vibrate)') {
                    // Scale PWM intensity (0-1022) to a 0-100 range for severity classification
                    scaledMetric = (metricValue / 1022) * 100;
                } else if (modeLabel === 'Tremor (FFT Metric)') {
                    // Scale FFT metric (0-150) to a 0-100 range for consistent severity
                    scaledMetric = (metricValue / 150) * 100;
                }
                // For 'Tremor (Simple Magnitude)', the simulated value is already 0-100, so no scaling needed.

                // Define severity thresholds (adjust as needed for real data and calibration)
                // These thresholds are illustrative and should be calibrated with real patient data and clinical guidance.
                if (scaledMetric < 30) {
                    severity = "Low";
                    severityClass = "severity-low";
                } else if (scaledMetric >= 30 && scaledMetric < 70) {
                    severity = "Moderate";
                    severityClass = "severity-moderate";
                } else {
                    severity = "High";
                    severityClass = "severity-high";
                }

                severityTextElement.textContent = `Severity: ${severity}`;
                // Remove previous severity classes and add the current one
                severityTextElement.className = ''; // Clear existing classes
                severityTextElement.classList.add(severityClass);

                timestampTextElement.textContent = `Last Updated: ${now}`;
            }

            // Function to simulate data and update the chart
            let simulateDataInterval; // Declare globally to clear later
            function simulateDataAndChart() {
                let simulatedVal;
                let currentModeLabel;

                const manualModeChecked = document.getElementById('manualModeRadio').checked;
                const simpleAnalysisModeChecked = document.getElementById('simpleAnalysisModeRadio').checked;
                const fftAnalysisModeChecked = document.getElementById('fftAnalysisModeRadio').checked;

                if (manualModeChecked) {
                    simulatedVal = Math.floor(Math.random() * 1023); // Random PWM value (0-1022)
                    currentModeLabel = 'Manual Mode (Fixed Vibrate)';
                } else if (simpleAnalysisModeChecked) {
                    simulatedVal = Math.random() * 100; // Simulated simple tremor magnitude (e.g., 0-100)
                    currentModeLabel = 'Tremor (Simple Magnitude)';
                } else if (fftAnalysisModeChecked) {
                    simulatedVal = Math.random() * 150; // Simulated FFT metric (e.g., 0-150)
                    currentModeLabel = 'Tremor (FFT Metric)';
                } else {
                    simulatedVal = 0; // Default if no mode is selected (shouldn't happen with radio buttons)
                    currentModeLabel = 'Unknown Mode';
                }

                const now = new Date().toLocaleTimeString();

                data.labels.push(now);
                data.datasets[0].data.push(parseFloat(simulatedVal));

                // Keep only the last 30 data points
                if (data.labels.length > 30) {
                    data.labels.shift();
                    data.datasets[0].data.shift();
                }
                chart.update();

                // Update the severity indicator
                updateSeverityIndicator(simulatedVal, currentModeLabel);
            }

            // --- Bluetooth Connection Logic ---
            const connectBluetoothBtn = document.getElementById('connectBluetoothBtn');
            const bluetoothConnectionStatus = document.getElementById('bluetoothConnectionStatus');

            // BLE Service and Characteristic UUIDs (These MUST match your ESP32 firmware)
            // You can generate custom UUIDs using online UUID generators (e.g., uuidgenerator.net)
            const ESP32_BLE_SERVICE_UUID = '4fafc201-1fb5-459e-8fcc-c5c9c331914b';
            const MODE_CHARACTERISTIC_UUID = 'beb5483e-36e1-4688-b7f5-ea07361b26a8'; // Write: manual (1) / auto (0)
            const LIVE_MODE_CHARACTERISTIC_UUID = 'beb5483e-36e1-4688-b7f5-ea07361b26a9'; // Write: live (1) / fft (0)
            const PWM_CHARACTERISTIC_UUID = 'beb5483e-36e1-4688-b7f5-ea07361b26aa'; // Write: PWM value (0-1022)
            const THRESHOLD_CHARACTERISTIC_UUID = 'beb5483e-36e1-4688-b7f5-ea07361b26ab'; // Write: Threshold value (float)
            const DATA_CHARACTERISTIC_UUID = 'beb5483e-36e1-4688-b7f5-ea07361b26ac'; // Notify: Tremor data (float)
            const GET_MANUAL_PWM_CHARACTERISTIC_UUID = 'beb5483e-36e1-4688-b7f5-ea07361b26ad'; // Read: Manual PWM
            const GET_AUTO_THRESHOLD_CHARACTERISTIC_UUID = 'beb5483e-36e1-4688-b7f5-ea07361b26ae'; // Read: Auto Threshold

            let esp32Device;
            let esp32Service;
            let modeCharacteristic;
            let liveModeCharacteristic;
            let pwmCharacteristic;
            let thresholdCharacteristic;
            let dataCharacteristic;
            let getManualPwmCharacteristic;
            let getAutoThresholdCharacteristic;

            function showBluetoothStatus(type, message) {
                bluetoothConnectionStatus.classList.remove('hidden', 'status-success', 'status-error', 'status-info');
                bluetoothConnectionStatus.classList.add(`status-${type}`);
                bluetoothConnectionStatus.innerText = message;
            }

            async function connectBluetooth() {
                try {
                    showBluetoothStatus('info', 'Searching for ESP32...');
                    esp32Device = await navigator.bluetooth.requestDevice({
                        filters: [{ services: [ESP32_BLE_SERVICE_UUID] }],
                        optionalServices: [
                            ESP32_BLE_SERVICE_UUID
                        ]
                    });

                    showBluetoothStatus('info', 'Connecting to GATT server...');
                    const server = await esp32Device.gatt.connect();

                    showBluetoothStatus('info', 'Getting service...');
                    esp32Service = await server.getPrimaryService(ESP32_BLE_SERVICE_UUID);

                    showBluetoothStatus('info', 'Getting characteristics...');
                    modeCharacteristic = await esp32Service.getCharacteristic(MODE_CHARACTERISTIC_UUID);
                    liveModeCharacteristic = await esp32Service.getCharacteristic(LIVE_MODE_CHARACTERISTIC_UUID);
                    pwmCharacteristic = await esp32Service.getCharacteristic(PWM_CHARACTERISTIC_UUID);
                    thresholdCharacteristic = await esp32Service.getCharacteristic(THRESHOLD_CHARACTERISTIC_UUID);
                    dataCharacteristic = await esp32Service.getCharacteristic(DATA_CHARACTERISTIC_UUID);
                    getManualPwmCharacteristic = await esp32Service.getCharacteristic(GET_MANUAL_PWM_CHARACTERISTIC_UUID);
                    getAutoThresholdCharacteristic = await esp32Service.getCharacteristic(GET_AUTO_THRESHOLD_CHARACTERISTIC_UUID);


                    // Start notifications for data updates from ESP32
                    await dataCharacteristic.startNotifications();
                    dataCharacteristic.addEventListener('characteristicvaluechanged', handleDataCharacteristicChange);

                    showBluetoothStatus('success', 'Connected to ESP32 via Bluetooth!');
                    showView(VIEWS.MAIN_APP); // Switch to main app view
                    // Stop simulating data once real data is expected from BLE
                    if (simulateDataInterval) clearInterval(simulateDataInterval);
                    simulateDataInterval = null; // Clear interval ID

                } catch (error) {
                    console.error("Bluetooth connection error:", error);
                    showBluetoothStatus('error', `Bluetooth connection failed: ${error.message}. Ensure ESP32 is advertising and Bluetooth is on.`);
                }
            }

            function handleDataCharacteristicChange(event) {
                const value = event.target.value; // DataView
                // Assuming ESP32 sends a float (4 bytes)
                const tremorMetric = value.getFloat32(0, true); // true for little-endian

                const now = new Date().toLocaleTimeString();
                data.labels.push(now);
                data.datasets[0].data.push(tremorMetric);

                // Keep only the last 30 data points
                if (data.labels.length > 30) {
                    data.labels.shift();
                    data.datasets[0].data.shift();
                }
                chart.update();

                updateSeverityIndicator(tremorMetric, getCurrentModeLabel());
            }

            // Functions to write to BLE characteristics
            async function writeToCharacteristic(characteristic, value) {
                if (!characteristic) {
                    console.error("Characteristic not available.");
                    return;
                }
                try {
                    // Determine data type based on characteristic
                    let dataToSend;
                    if (characteristic === modeCharacteristic || characteristic === liveModeCharacteristic) {
                        dataToSend = new Uint8Array([value ? 1 : 0]); // Boolean as 1-byte integer
                    } else if (characteristic === pwmCharacteristic) {
                        dataToSend = new Uint16Array([value]); // PWM as 2-byte integer (0-1022)
                    } else if (characteristic === thresholdCharacteristic) {
                        dataToSend = new Float32Array([value]); // Threshold as 4-byte float
                    } else {
                        console.error("Unknown characteristic type for writing.");
                        return;
                    }
                    await characteristic.writeValue(dataToSend);
                    console.log(`Wrote ${value} to ${characteristic.uuid}`);
                } catch (error) {
                    console.error(`Error writing to characteristic ${characteristic.uuid}:`, error);
                    showBluetoothStatus('error', `Failed to send command: ${error.message}`);
                }
            }

            // Functions to read from BLE characteristics
            async function readFromCharacteristic(characteristic) {
                if (!characteristic) {
                    console.error("Characteristic not available for reading.");
                    return null;
                }
                try {
                    const value = await characteristic.readValue();
                    if (characteristic === getManualPwmCharacteristic) {
                        return value.getUint16(0, true); // Read 2-byte integer (PWM)
                    } else if (characteristic === getAutoThresholdCharacteristic) {
                        return value.getFloat32(0, true); // Read 4-byte float (Threshold)
                    }
                    console.warn(`Unhandled read for characteristic ${characteristic.uuid}`);
                    return null;
                } catch (error) {
                    console.error(`Error reading from characteristic ${characteristic.uuid}:`, error);
                    showBluetoothStatus('error', `Failed to read data: ${error.message}`);
                    return null;
                }
            }


            // Event listeners for main app controls (modified for Bluetooth)
            document.getElementById('manualModeRadio').onchange = async () => {
                const manualChecked = document.getElementById('manualModeRadio').checked;
                const simpleAnalysisChecked = document.getElementById('simpleAnalysisModeRadio').checked;
                const fftAnalysisChecked = document.getElementById('fftAnalysisModeRadio').checked;

                await writeToCharacteristic(modeCharacteristic, manualChecked); // Send manual mode state

                if (!manualChecked) { // If switching to auto mode
                    await writeToCharacteristic(liveModeCharacteristic, simpleAnalysisChecked); // Send live/fft state
                }
                updateUIState();
            };

            document.getElementById('simpleAnalysisModeRadio').onchange = async () => {
                if (!document.getElementById('manualModeRadio').checked) {
                    await writeToCharacteristic(liveModeCharacteristic, true); // Set to live analysis
                }
                updateUIState();
            };

            document.getElementById('fftAnalysisModeRadio').onchange = async () => {
                if (!document.getElementById('manualModeRadio').checked) {
                    await writeToCharacteristic(liveModeCharacteristic, false); // Set to FFT analysis
                }
                updateUIState();
            };

            document.getElementById('controlSlider').oninput = async e => {
                const v = parseFloat(e.target.value);
                document.getElementById('controlVal').innerText = v.toFixed(0);
                const manualChecked = document.getElementById('manualModeRadio').checked;
                if (manualChecked) {
                    await writeToCharacteristic(pwmCharacteristic, parseInt(v.toFixed(0)));
                } else {
                    await writeToCharacteristic(thresholdCharacteristic, v);
                }
                updateSeverityIndicator(v, getCurrentModeLabel());
            };

            // Function to update UI element states and slider based on mode (fetches current values from ESP32 via BLE)
            async function updateUIState() {
                const manualChecked = document.getElementById('manualModeRadio').checked;
                const simpleAnalysisChecked = document.getElementById('simpleAnalysisModeRadio').checked;
                const fftAnalysisChecked = document.getElementById('fftAnalysisModeRadio').checked;

                const controlSlider = document.getElementById('controlSlider');
                const controlLabel = document.getElementById('controlLabel');
                const controlVal = document.getElementById('controlVal');

                // Disable simple/fft analysis radios if manual mode is active
                document.getElementById('simpleAnalysisModeRadio').disabled = manualChecked;
                document.getElementById('fftAnalysisModeRadio').disabled = manualChecked;

                let currentMetricForIndicator = 0;
                let currentModeLabelForIndicator = '';

                if (manualChecked) {
                    controlLabel.innerText = 'Manual PWM Intensity: ';
                    controlSlider.min = '0';
                    controlSlider.max = '1022';
                    const val = await readFromCharacteristic(getManualPwmCharacteristic);
                    if (val !== null) {
                        controlSlider.value = val;
                        controlVal.innerText = val;
                    }
                    chart.data.datasets[0].label = 'Manual Mode (Fixed Vibrate)';
                    chart.options.scales.y.suggestedMax = 1023;
                    currentModeLabelForIndicator = 'Manual Mode (Fixed Vibrate)';
                    currentMetricForIndicator = parseFloat(controlSlider.value); // Use slider value for indicator
                } else {
                    controlSlider.min = '0'; // Reset min for auto modes
                    if (simpleAnalysisChecked) {
                        controlLabel.innerText = 'Simple Tremor Threshold: ';
                        controlSlider.max = '100'; // Max threshold for live magnitude
                        chart.data.datasets[0].label = 'Tremor (Simple Magnitude)';
                        chart.options.scales.y.suggestedMax = 100;
                        currentModeLabelForIndicator = 'Tremor (Simple Magnitude)';
                    } else if (fftAnalysisChecked) {
                        controlLabel.innerText = 'FFT Tremor Threshold: ';
                        controlSlider.max = '200'; // Max threshold for FFT metric
                        chart.data.datasets[0].label = 'Tremor (FFT Metric)';
                        chart.options.scales.y.suggestedMax = 200;
                        currentModeLabelForIndicator = 'Tremor (FFT Metric)';
                    }
                    const val = await readFromCharacteristic(getAutoThresholdCharacteristic);
                    if (val !== null) {
                        controlSlider.value = val;
                        controlVal.innerText = val.toFixed(0);
                    }
                    currentMetricForIndicator = parseFloat(controlSlider.value); // Use slider value for indicator
                }
                chart.update();
                updateSeverityIndicator(currentMetricForIndicator, currentModeLabelForIndicator);
            }

            // Event listener for Bluetooth Connect Button
            connectBluetoothBtn.addEventListener('click', connectBluetooth);

            // Start simulating data initially if no BLE connection is made
            // This will be cleared once a successful BLE connection is established.
            if (!simulateDataInterval) {
                simulateDataInterval = setInterval(simulateDataAndChart, 500);
            }

            // Service Worker registration for PWA features
            if ('serviceWorker' in navigator) {
                window.addEventListener('load', () => {
                    navigator.serviceWorker.register('/service-worker.js')
                        .then(registration => {
                            console.log('Service Worker registered: ', registration);
                        })
                        .catch(error => {
                            console.error('Service Worker registration failed: ', error);
                        });
                });
            }
        </script>
    </body>
    </html>
    